<h1>Cours | Les bases de la programmation en Ruby</h1>

<h2>1. Introduction</h2>
<p>Avant de rentrer dans le d√©tail du fonctionnement de Ruby, on voudrait te faire un topo g√©n√©ral sur la programmation. L'objectif est que tu comprennes bien la logique globale de l'informatique, comment marche un programme et du coup comment tu dois r√©fl√©chir quand tu codes en Ruby.</p>
<p>Une fois les explications g√©n√©rales faites, on va te pr√©senter l'IRB : cet outil te permet de rentrer du code Ruby √† la vol√©e (sans √©crire de programme complet dans un fichier) et d'en obtenir le r√©sultat tr√®s rapidement √† partir de ton terminal. C'est super pratique pour tester quelques lignes de Ruby afin d'en voir le fonctionnement.</p>
<p>Il y aura tr√®s probablement des redites avec ce que tu as d√©j√† vu durant la semaine 0 du pr√©parcours. Mais comme je ne sais pas dans quelles conditions tu as fait cette semaine et vu qu'il n'est jamais mauvais de r√©p√©ter les choses 2 fois pour bien les fixer, reprenons tout depuis le d√©but.</p>

<h2>2. Historique et contexte</h2>
<p>La programmation informatique trouve ses origines dans la seconde guerre mondiale lorsque les alli√©s ont, pour la premi√®re fois, utilis√© des machines pour acc√©l√©rer et automatiser le d√©cryptage des messages ennemis. Le domaine est rest√© assez confidentiel et limit√© √† la recherche, les usages militaires et les entreprises sp√©cialis√©es jusque dans les ann√©es 70 avant d'exploser avec l'av√®nement des Personal Computers dans les ann√©es 80.</p>
<p>Le langage Ruby a √©t√© invent√© au moment de la d√©mocratisation d'Internet (milieu des ann√©es 90) par le japonais <a href="https://en.wikipedia.org/wiki/Yukihiro_Matsumoto">Yukihiro Matsumoto</a>. Il avait √† c≈ìur de cr√©er un langage orient√© objet qui soit facile et plaisant √† utiliser. C'est d'ailleurs une caract√©ristique forte de Ruby : on peut le lire presque comme s'il s'agissait de phrases l√† o√π de nombreux langages croulent sous les ponctuations indigestes <code> { (  ) } ; </code> et font appel √† des fonctions aux noms plus que myst√©rieux‚Ä¶</p>
<p>Quant √† IRB, c'est l'acronyme de "Interactive Ruby" ("Ruby" √©tant compress√© en RB, l'extension <code>.rb</code> des fichiers Ruby). C'est ce que l'on appelle un "Read‚Äìeval‚Äìprint loop" (REPL) qui sont des types d'environnement permettant d'utiliser un langage via son terminal.</p>

<h2>3. La ressource</h2>
<h3>3.1. C'est quoi au juste un programme ?</h3>
<p>Un programme informatique n'est ni plus ni moins qu'une liste d'instructions qui doivent √™tre ex√©cut√©es par un ordinateur. Ces instructions sont saisies dans un ou plusieurs fichiers qui seront lus et interpr√©t√©s lors de l'ex√©cution. Mais pour √™tre lisibles par l'ordinateur, il faut que ces instructions soient r√©dig√©es dans un langage informatique donn√©, ce dernier n'√©tant rien d'autre qu'un ensemble de r√®gles permettant √† l'ordinateur (qui lit) et au d√©veloppeur informatique (qui r√©dige) de bien se comprendre.</p>

<p>Tout comme une langue vivante, un langage informatique dispose d'un vocabulaire (mots ayant un r√¥le et une signification sp√©cifique. Par exemple les mots suivants ont une fonction pr√©cise en Ruby : <code>puts</code>, <code>Class</code>, <code>if</code>, etc.) et une grammaire (ensemble de r√®gles qui doivent √™tre respect√©es pour r√©diger le programme. Par exemple en Ruby, on doit sauter des lignes entre chaque instruction, terminer une m√©thode par <code>end</code>, etc.)</p>

<p>Chez THP, nous allons t'apprendre le vocabulaire et la grammaire de Ruby pour que tu disposes de tous les outils n√©cessaires pour programmer √† peu pr√®s tout et n'importe quoi. Mais on va √©galement te guider, √† travers des projets, dans la r√©daction de tes premiers programmes Ruby afin que tu voies directement l'√©tendue des possibilit√©s qui s'offrent √† toi !</p>

<h3>3.2. Quelle est la logique derri√®re l'√©criture d'un programme ?</h3>
<p>Un programme informatique est toujours √©crit dans un but pr√©cis : r√©soudre un probl√®me bien d√©fini. C'est m√™me sa seule raison d'√™tre et la seule raison pour laquelle un d√©veloppeur l'a, un jour, cod√©. Et pour arriver √† r√©soudre ce probl√®me, le programme va comporter une s√©rie d'actions qu'il va ex√©cuter "froidement" (entendez par l√† qu'il va les ex√©cuter une √† une sans r√©fl√©chir).</p>

<p>Mais quand on y regarde de pr√®s, ce que nous, humains, faisons au quotidien pourrait √©galement √™tre d√©crit comme une sorte de programme informatique : pour r√©soudre un probl√®me (notamment s'il est r√©current et bien connu), nous aussi on d√©roule une s√©rie d'actions. <br>
Prenons un exemple du quotidien : faire les courses (qui revient √† r√©soudre le probl√®me "je dois remplir mon frigo"). On peut imaginer cela sous la forme d'une suite d'actions du style :</p>

<pre><code class="language-bash">- Entrer dans le magasin
- Sortir sa liste de courses
- Lire le premier √©l√©ment de la liste
- Se diriger vers le rayon ad√©quat
- Si un article correspondant est disponible, le prendre et le mettre dans son panier
- Lire le second √©l√©ment de la liste
- Se diriger vers le rayon ad√©quat
- Si un article correspondant est disponible, le prendre et le mettre dans son panier
- Se diriger vers la caisse
- Attendre son tour
- Dire bonjour
- Pr√©senter les articles √† la caisse puis les remettre dans son panier
- Payer
- Dire au revoir
- Sortir du magasin</code></pre>

<p>On retrouve l√† toutes les caract√©ristiques d'un programme informatique:</p>
<ul>
  <li><b>L'ensemble est d√©coup√© en instructions bien distinctes et isol√©es</b>. C'est pour cela que, naturellement, je l'ai pr√©sent√© sous forme de liste : √† chaque ligne, une instruction.</li>
  <li><b>Des variables rentrent en jeu</b>. Certaines sont en entr√©e (une liste de courses qu'on a au d√©part), d'autres sont utilis√©es au cours du programme (elles sont stock√©es dans la t√™te de la personne qui fait les courses : le nombre d'articles qu'il a mis dans le panier, le nombre d'article restant sur la liste, etc.) et certaines peuvent √™tre transmises en fin de programme (Il va informer ses colocs du prix qu'il a pay√© pour partager les frais, etc.).</li>
  <li><b>Certaines instructions sont r√©p√©t√©es en boucle</b> : on d√©roule la liste article par article et √† chaque fois on fait la m√™me chose (lecture, d√©placement vers le rayon, prendre l'article, le mettre dans le panier, etc.) </li>
  <li><b>Certaines instructions sont conditionn√©es √† un test</b> : est-ce qu'un article est pr√©sent en rayon ? Si oui, le mettre dans le panier. Si non, on continue les courses.</li>
  <li><b>Certaines instructions se ressemblent beaucoup</b> : seul un √©l√©ment ou deux change (Se diriger vers le rayon / vers la caisse, Dire Bonjour / Au revoir. C'est typiquement le genre d'instruction qu'on transformera ensuite en m√©thodes (les fonctions en Ruby).</li>
</ul>

<p>Au final, si on demandait √† un d√©veloppeur informatique d'√©crire un programme pour r√©soudre le probl√®me "je dois remplir mon frigo", son premier r√¥le sera de lister la suite logique d'actions √† mener. Il aboutirait alors √† un r√©sultat proche de la liste d'instructions ci-dessus. </p>

<p>Mais √† la diff√©rence d'un humain, le programme informatique a une particularit√© : il est incapable de prendre une initiative. S'il rencontre une situation inconnue, non pr√©vue, il va bloquer : c'est le fameux "bug". Le deuxi√®me r√¥le du d√©veloppeur informatique est donc d'anticiper tous les cas de figure possibles (ou a minima un maximum de cas de figure) afin que le programme ne soit jamais bloqu√©. <br>
Par exemple, si la personne faisant les courses oublie son portefeuille, on va buguer √† l‚Äô√©tape "Payer". Du coup, si ce cas de figure est envisageable, le d√©veloppeur doit l'anticiper avec une instruction un peu plus d√©taill√©e que "Payer". Par exemple :

<pre><code class="language-bash">- Si j'ai bien mon portefeuille, je paye. Sinon je pose mon panier et je sors du magasin.</code></pre>

<p>Idem si jamais la liste de courses contient 3 √©l√©ments : dans l'exemple ci-dessus, le 3√®me √©l√©ment ne sera jamais achet√©. Il faut pouvoir √©crire un programme qui s'adapte s'il y a 3 ou 5 ou 100 √©l√©ments sur la liste de courses. Tout cela est ce qu'on appelle <b>l'algorithmie</b>, l'art de r√©diger des algorithmes que Wikip√©dia d√©fini comme "une suite finie et non ambigu√´ d‚Äôop√©rations ou d'instructions permettant de r√©soudre une classe de probl√®mes".</p>

<p>Au final, pour √©crire un programme complet et fiable qui r√©sout bien le probl√®me cibl√©, un bon d√©veloppeur doit proc√©der par √©tapes :</p>
<ol>
  <li>R√©fl√©chir avant de coder √† la fa√ßon dont les actions doivent se succ√©der ;</li>
  <li>Poser les bases de son programme ;</li>
  <li>Faire tourner (tester) son programme sur des cas simples (ex : je fais mes courses et tout va bien) et le modifier en cas de probl√®me ;</li>
  <li>Faire tourner (tester) son programme sur des cas tordus mais plausibles (ex : je fais mes courses mais j'ai oubli√© mon argent / il n'y a pas de caisse libre / un √©l√©ment de la liste est illisible / etc.) et le modifier en cas de probl√®me.</li>
</ol>

<h3>3.3. Les actions de bases en Ruby</h3>
<p>Maintenant que tu as compris la logique globale d'un programme informatique, posons les premi√®res briques d'un programme Ruby. Afin de pratiquer ce que je vais te pr√©senter, tu vas ex√©cuter des instructions en Ruby directement dans ton terminal via l'IRB. √áa va nous √©viter d'avoir √† r√©diger un fichier <code>.rb</code> puis de le lancer.</p>
<p>Pour d√©marrer IRB, ex√©cute dans ton terminal:</p>
<pre><code class="language-bash">$ irb</code></pre>

<p>Pour sortir de IRB, ex√©cute dans l'IRB:</p>
<pre><code class="language-ruby">2.5.1 :001 > quit</code></pre>

<div class="card box-shadow-0 border-danger">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">‚ö†Ô∏è ALERTE ERREUR COMMUNE</h4>
      <p class="card-text">Dans le stress, il est arriv√© de voir des moussaillons √©crire des lignes de commande destin√©es √† leur terminal (<code>ls</code>, <code>cd ..</code>, <code>git truc</code>, etc.) alors qu'ils √©taient dans IRB. Si jamais tu vois des lignes comme ceci dans ton terminal :</p>
      <pre><code class="language-bash">2.5.1 :001 > git init
Traceback (most recent call last):
        2: from /home/felix/.rvm/rubies/ruby-2.5.1/bin/irb:11:in `&lt;main>'
        1: from (irb):1
NameError (undefined local variable or method `init' for main:Object)</code></pre>
      <p>C'est que tu as √©crit dans l'IRB une commande destin√©e √† ton terminal : quitte l'IRB, recommence ta saisie et sois plus attentif ! üòâ</p>
    </div>
  </div>
</div>

<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">üöÄ ALERTE BONNE ASTUCE</h4>
      <p class="card-text">Avec les fl√®ches HAUT et BAS de ton clavier, tu peux naviguer entre les derni√®res instructions que tu as d√©j√† tap√©es dans IRB (idem que dans ton terminal). Pratique pour reprendre une instruction pass√©e et la modifier.</p>
      <p>Avec <code>CTRL + L</code>, tu peux vider ton IRB pour y voir plus clair.</p>
    </div>
  </div>
</div>

<h4>3.3.1. Afficher, avec Ruby, quelque chose dans le terminal</h4>
<p>Tu connais d√©j√† la m√©thode <code>puts</code> qui permet d'afficher un r√©sultat de ton programme Ruby directement dans ton terminal. Eh bien sache que dans certains langages, cette m√™me action n√©cessite 3 lignes de code ! Tape dans ton IRB l'instruction : <code>puts "Hello World!"</code>. Tu devrais obtenir :</p>

<pre><code class="language-bash">2.5.1 :007 > puts "Hello World!"
Hello World!
 => nil</code></pre>

 <p>Cet affichage dans IRB signifie qu'une telle instruction aurait affich√© <code>Hello World!</code> dans ton terminal (exactement de la fa√ßon dont elle s'affiche l√†). La partie <code>=> nil</code> signifie que cette instruction ne retourne aucune valeur : quand tu mets un <code>puts</code>, aucune variable n'est stock√©e nulle part.</p>

<h4>3.3.2. Stocker une information dans une variable</h4>
<p>Une variable, en informatique (ou m√™me en math√©matiques), c'est comme une boite dans laquelle on va stocker une information. On va ensuite pouvoir, quand on le souhaite, lire cette information, la modifier, l'utiliser pour faire des op√©rations ou la supprimer. </p>
<p>Une variable est d√©finie par : </p>
<ol>
  <li><b>Son type</b> : <code>String</code> (cha√Æne de caract√®re), <code>Integer</code> (un nombre entier ‚Äì prononcez [ine-t√©-djeur]), <code>Float</code> (un nombre avec des d√©cimales), <code>Boolean</code> (soit true soit false, ce qui permet d'avoir une information en mode oui / non).</li>
  <li><b>Sa valeur</b> :</li>
  <ul>
    <li>Boolean (il n'y a que 2 valeurs) : <code>true</code> ou <code>false</code></li>
    <li>Exemples de Integer : <code>43</code>, etc.</li>
    <li>Exemples de Float : <code>43.0</code>, <code>43.1</code>, <code>1.3333333</code>, etc.</li>
    <li>Exemples de string : <code>"hello world"</code>, <code>"43"</code>, <code>"true"</code>, <code>"hello true 43 &@√ß¬£%# "</code>, etc.</li>
  </ul>
</ol>

<p>En Ruby, pour d√©clarer une variable, il suffit d'√©crire le nom qu'on veut donner √† la variable suivie de <code>=</code> et de la valeur. La valeur saisie d√©terminera le type de la variable. <br>
Rentre les lignes suivantes dans IRB (l'une apr√®s l'autre) : <code>nom_du_mod√®le = "Zo√©"</code> ‚Äì <code>kilom√©trage = 145000</code> ‚Äì <code>en_vente = true</code></p>

<p>√Ä pr√©sent tu peux rappeler quand tu veux ces variables simplement en entrant leur nom. <code>nom_du_mod√®le</code> te retournera <code>"Zo√©"</code>, <code>kilom√©trage</code> te retourne <code>145000</code>, etc. Si tu sors de l'IRB, l'ensemble des variables que tu auras d√©clar√©es seront effac√©es.</p>

<p>Tu peux modifier ces variables √† volont√© en changeant tout (leur type, leur valeur) autant de fois que tu le souhaites. Par exemple (fais le test en parall√®le sur ton IRB) :</p>

<pre><code class="language-bash">2.5.1 :016 > nom_du_mod√®le = "Zo√©"
 => "Zo√©" 
2.5.1 :017 > nom_du_mod√®le = "Tweezy"
 => "Tweezy" 
2.5.1 :018 > nom_du_mod√®le
 => "Tweezy" 
2.5.1 :019 > nom_du_mod√®le = kilom√©trage
 => 145000 
2.5.1 :020 > nom_du_mod√®le
 => 145000 </code></pre>

<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">üöÄ ALERTE BONNE ASTUCE</h4>
      <p class="card-text">Tu peux facilement obtenir le type d'une variable ou d'une valeur avec la m√©thode <code>.class</code>. Fais les tests suivants dans ton IRB (fais particuli√®rement attention aux 4 derniers qui sont int√©ressants) : </p>
      <pre><code class="language-bash">2.5.1 :002 > "Zo√©".class
 => String 
2.5.1 :003 > 145000.class
 => Integer 
2.5.1 :004 > kilom√©trage.class
 => Integer 
2.5.1 :005 > 3.5.class
 => Float 
2.5.1 :006 > "145000".class
 => String
2.5.1 :007 > true.class
 => TrueClass 
2.5.1 :008 > false.class
 => FalseClass </code></pre>
      <p>Tu auras compris qu'il n'y a pas de class "Boolean" en Ruby mais deux classes <code>TrueClass</code> et <code>FalseClass</code>.</p>
    </div>
  </div>
</div>



<h4>3.3.3. Obtenir une saisie utilisateur depuis le terminal</h4>
<p>Pour que l'utilisateur puisse rentrer une information, on utilise la m√©thode <code>gets.chomp</code> dont le r√©sultat est stock√© dans une variable qu'on pourra appeler ensuite. Essaye cela en saisissant dans ton IRB <code>input = gets.chomp</code>, tape quelque chose dans le terminal (suivi de ENTER) et enfin appelle √† nouveau la variable dans l'IRB avec <code>input</code> pour v√©rifier que la donn√©e a bien √©t√© stock√©e et peut √™tre utilis√©e.</p>
<p>Note bien que la saisie via <code>gets.chomp</code> est toujours de type <code>String</code> (m√™me si tu saisis un chiffre, il sera sous forme de <code>String</code>).</p>

<h4>3.3.4. Faire des op√©rations entre variables</h4>
<p>Une fois des variables d√©clar√©es, on peut les combiner gr√¢ce aux op√©rateurs math√©matiques de base : <code>+</code> (addition), <code>-</code> (soustraction), <code>*</code> (multiplication) ou encore <code>/</code>(division). Cela marche √©videmment avec des <code>Integer</code> : </p>

<pre><code class="language-bash">2.5.1 :014 > chiffre_1 = 3
 => 3 
2.5.1 :015 > chiffre_1 + 4 * chiffre_1
 => 15 
2.5.1 :016 > chiffre_1 = chiffre_1 - 1
 => 2 
2.5.1 :017 > chiffre_1 + 4 * chiffre_1
 => 10</code></pre>

 <p>Mais on peut √©galement concat√©ner 2 strings avec <code>+</code> : </p>

 <pre><code class="language-bash">2.5.1 :018 > dessert = "gateau" + " " + "de riz" 
 => "gateau de riz" 
2.5.1 :019 > "je mangerais bien un" + " " + dessert
 => "je mangerais bien un gateau de riz"</code></pre>

<h4>3.3.5. Op√©rations et types de donn√©es</h4>
 <p>Si on essaye d'effectuer des op√©rations entre types diff√©rents, Ruby n'est pas d'accord : </p>
 <pre><code class="language-bash">2.5.1 :020 > 3 + "3"
Traceback (most recent call last):
        3: from /usr/share/rvm/rubies/ruby-2.5.1/bin/irb:11:in `<main>'
        2: from (irb):20
        1: from (irb):20:in `+'
TypeError (String can't be coerced into Integer)</code></pre>

<p>Seule solution : changer le type quand c'est possible avec les m√©thodes <code>.to_s</code> (qui transforme en <code>String</code>), <code>.to_i</code> (qui transforme en <code>Integer</code>) et <code>to_f</code> (qui transforme en <code>Float</code>). Regarde bien en d√©tails les exemples ci-dessous et teste-les dans ton IRB : </p>

 <pre><code class="language-bash">2.5.1 :002 > my_number = "3".to_i
 => 3 
2.5.1 :003 > my_number.class
 => Integer 
2.5.1 :004 > my_float = "3".to_f
 => 3.0 
2.5.1 :005 > my_float.class
 => Float 
2.5.1 :006 > word = 3.to_s
 => "3" 
2.5.1 :007 > word.class
 => String </code></pre>

 <div class="card box-shadow-0 border-danger">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">‚ö†Ô∏è ALERTE ERREUR COMMUNE</h4>
      <p class="card-text">Un dernier point qui est √† l'origine de nombreux cheveux arrach√©s chez les d√©butants en code : les op√©rations entre <code>Integer</code> et <code>Float</code>. Retenez cette r√®gle : une op√©ration ne comportant que des <code>Integer</code> donnera un r√©sultat de type <code>Integer</code> arrondi √† l'entier inf√©rieur.<b> Pour obtenir un r√©sultat pr√©cis √† la virgule pr√®s (de type <code>Float</code> donc), il faut qu'au moins une des donn√©es de l'op√©ration soit un <code>Float</code></b>. Illustration : </p>

 <pre><code class="language-bash">2.5.1 :023 > 11 / 6
 => 1 
2.5.1 :024 > 11.0 / 6
 => 1.8333333333333333 
2.5.1 :025 > 11 / 6.to_f
 => 1.8333333333333333</code></pre>

      <p>Faites tr√®s attention aux types de vos donn√©es quand vous faites des op√©rations math√©matiques. En ayant uniquement des <code>Integer</code>, vous allez perdre toutes les informations apr√®s la virgule et obtenir des r√©sultats grossi√®rement erron√©s.</p>
    </div>
  </div>
</div>

<h2>4. Points importants √† retenir</h2>
<p>Un programme est une suite d'instructions destin√©es √† r√©soudre un probl√®me bien d√©fini. Ces instructions seront lues par un ordinateur qui va les appliquer sans r√©fl√©chir, dans l'ordre de leur lecture. Le travail du d√©veloppeur est de d√©terminer quelles instructions doivent √™tre effectu√©es et dans quel ordre afin de r√©soudre le probl√®me. Il doit anticiper tous les cas envisageables afin d'√©viter que l'ordinateur ne se retrouve dans une situation non pr√©vue, synonyme de bug.</p>
<p>Afin de tester facilement une instruction Ruby, on peut passer par l'IRB que l'on lance dans le terminal avec <code>$ irb</code> et que l'on quitte avec <code>2.5.1 :001 > quit</code>.</p>
<p>Un programme Ruby peut afficher des donn√©es dans le terminal avec la m√©thode <code>puts</code>. Il peut demander une information, sous forme de <code>String</code>, √† l'utilisateur avec la m√©thode <code>gets.chomp</code>.</p>
<p>Une variable est une "bo√Æte" permettant de stocker une donn√©e et d√©finie par son type (String, Integer, Float, Boolean, etc.) et sa valeur ("hello", 4, true, 5.6, etc.)</p>
<p>On peut faire des op√©rations entre variables avec les op√©rateurs math√©matiques classiques <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>. Auparavant, il faut s'assurer du type de donn√©e que renferme chaque variable, notamment avec <code>.class</code>.</p>
<p>On peut facilement convertir une variable d'un type √† l'autre avec les m√©thodes <code>to_s</code> (vers un <code>String</code>), <code>to_i</code> (vers un <code>Integer</code>) ou encore <code>to_f</code> (vers un <code>Float</code>).</p>


<h2>5. Pour aller plus loin</h2>
<p>Pour aller plus loin‚Ä¶ fini la journ√©e ! üòò</p>
<p>Si jamais tu veux aller plus loin sur le sujet de l'IRB, sache que tu peux t'amuser √† <a href="https://www.rubyguides.com/2016/07/writing-a-shell-in-ruby/" target="_blank">coder toi-m√™me</a> ton propre REPL.</p>

<h1>Cours | Les m√©thodes (fonctions en Ruby)</h1>
<h2>1. Introduction</h2>
<p>En informatique, une fonction est un bout de code que tu peux ex√©cuter et appeler √† tout moment. <b>Une fonction a un r√¥le tr√®s pr√©cis avec g√©n√©ralement (mais pas obligatoirement) des donn√©es en entr√©e et des donn√©es en sortie</b>. Il faut la consid√©rer comme une "mini-usine" qui produit toujours la m√™me chose d√®s que tu la d√©clenches (en l'appelant): c'est un concept indispensable et une base fondamentale de l'art de coder. Par exemple, voici un programme qui d√©finit une fonction <code>hello_sayer</code> puis qui l'appelle 2 lignes plus tard :</p>

<pre><code class="language-ruby">def hello_sayer #fonction dont le r√¥le est d'afficher "Hello world !"
  puts "Hello world !"
end

hello_sayer # ligne pour appeler la fonction </code></pre>

<p>Dans cette ressource, nous allons voir comment d√©finir des <b>m√©thodes</b> en ruby (c'est le nom que ruby donne aux fonctions), et comment s'en servir.</p>

<h2>2. Historique</h2>
<p>Le terme fonction est inspir√© des fonctions math√©matiques. Ce concept existe depuis tr√®s longtemps et est g√©r√© par la majorit√© des langages de programmation.</p>

<h2>3. La ressource</h2>
<h3>3.1. Les bases des m√©thodes</h3>
<p>Les m√©thodes peuvent para√Ætre un peu chelou √† la base, mais elles sont indispensables pour faire du code propre. Dans le projet du jour, <b>vous allez travailler exclusivement avec des m√©thodes</b>. Notre ami Jonathan de Grafikart a fait <a href="https://www.grafikart.fr/tutoriels/method-670" target="_blank" class="text-primary">un article et vid√©o</a> qui expliquent les m√©thodes en Ruby.</p>

<h3>3.2. Pourquoi utiliser des m√©thodes¬†?</h3>
<p>Un autre √©l√©ment important pour produire du code lisible est de <b>classer et tout bien ranger dans des m√©thodes</b>. Chaque m√©thode doit avoir une fonction bien pr√©cise: elle r√©sout un mini-probl√®me donn√©. Quand tout un programme est d√©coup√© en m√©thodes, cela permet de plus facilement s'y retrouver, de pouvoir donner un sens √† chaque ligne de code (une m√©thode = un r√¥le, donc on voit ce que le groupe de lignes de code doit faire), et au final de corriger plus facilement ses bugs. Que des avantages¬†! <b>Il faut donc organiser votre programme en une succession de m√©thodes avec interdiction d'avoir du code en dehors d'une m√©thode.</b> Et pour chapeauter le tout, on r√©dige une m√©thode souvent appel√©e <code>perform</code> qui orchestre l'ex√©cution de la m√©thode A, puis de la B, puis qui cr√©√© une variable qu'on injecte dans la C, etc.</p>
 <p> ‚ö†Ô∏èN'oubliez pas de conclure votre programme par la ligne <code>perform</code> pour appeler cette m√©thode "orchestre". Sinon il ne se passera rien‚Ä¶ üòè </p> 


<h3>3.3. Comment l'ordinateur interpr√®te-t-il les m√©thodes¬†?</h3>
<p>Pour illustrer cela, prenons l'exemple d'un programme qui demande le nom complet de quelqu'un. Nous allons cr√©er une m√©thode <code>ask_first_name</code> et une m√©thode <code>ask_last_name</code> que nous allons appeler dans une m√©thode <code>ask_full_name</code> üëå</p>

<pre><code class="language-ruby">def ask_first_name
  puts "Quel est ton pr√©nom ?"
  print "> "
  first_name = gets.chomp
  return first_name
end

def ask_last_name
  puts "Quel est ton nom de famille ?"
  print "> "
  last_name = gets.chomp
  return last_name
end

def greet(first_name, last_name)
  puts "Bienvenue, #{first_name} #{last_name} !"
end

def perform
  first_name = ask_first_name
  last_name = ask_last_name
  greet(first_name, last_name)
end

perform</code></pre>

<p>OK quand tu vois √ßa et que tu viens tout juste de commencer √† coder, tu peux pas mal flipper¬†: <b>y a beaucoup de lignes, par o√π je commence pour piger ce que fait ce programme¬†?</b> Pas de panique on va t'aider √† le d√©crypter ligne par ligne.</p>

<p>Tout d'abord, on va le lire exactement comme l'ordinateur le lirait¬†: <b>de haut en bas</b>. On commence par le haut donc. <br>
On voit que le code commence par d√©finir une m√©thode avec la ligne <code>def ask_first_name</code>¬†: instinctivement tu peux d√©j√† chercher la fin de cette m√©thode avec le <code>end</code>. Si tu fais √ßa en cherchant les d√©buts de m√©thodes (<code>def</code>) et leurs fins (<code>end</code>) tu vas pouvoir prendre de la hauteur et te rendre compte que ce code est en fait organis√© ainsi¬†: </p>

<pre><code class="language-ruby"> [M√©thode 1: "ask_first_name" - pas d'entr√©e]

[M√©thode 2: "ask_last_name" - pas d'entr√©e]

[M√©thode 3: "greet" - 2 entr√©es : "first name" et "last name"]

[M√©thode 4: "perform" - pas d'entr√©e]

[une ligne de code seule qui ex√©cute la m√©thode "perform"]</code></pre>

<p>On a donc 4 m√©thodes et en lisant de haut en bas, l'ordinateur va proc√©der √©tape par √©tape. <br>
‚ö†Ô∏è Prends bien le temps de lire attentivement ce d√©roul√© afin de bien comprendre la logique d'ex√©cution du code. </p>

<h4>√âtape 1¬†: lecture des m√©thodes (en l'absence de ligne d'ex√©cution)</h4>
<ol>
  <li>Il lit la m√©thode <code>ask_first_name</code>. Elle est d√©finie mais rien ne l‚Äôex√©cute donc il met juste dans un coin de sa m√©moire "il faudra lire le contenu de cette m√©thode si jamais quelque chose l'ex√©cute".</li>

  <li>Il fait pareil avec la m√©thode <code>ask_last_name</code>. Toujours pas d'ex√©cution donc il ne fait que l'identifier et se dire "ok, une m√©thode portant ce nom est l√†". Idem pour les m√©thodes <code>greet</code> et <code>perform</code>.</li>

  <li>Puis l'ordinateur arrive √† la ligne <code>perform</code>. Elle signifie "ex√©cute la m√©thode nomm√©e <code>perform</code>". <b>Du coup l'ordinateur va enfin ex√©cuter quelque chose¬†!</b> Le code de la m√©thode va √™tre ex√©cut√© :</li>
<pre><code class="language-ruby">def perform
  first_name = ask_first_name
  last_name = ask_last_name
  greet(first_name, last_name)
end</code></pre>
</ol>

<h4>√âtape 2¬†: ex√©cution ligne par ligne de <code>perform</code></h4>
  <ul>
    <li><b>La premi√®re ligne, <code>first_name = ask_first_name</code></b> d√©fini une variable, <code>first_name</code>, √©gale au r√©sultat d'une m√©thode¬†: <code>ask_first_name</code>.</li>

    <ul>
      <li> Hop, l'ordinateur va ex√©cuter¬†: </li>
<pre><code class="language-ruby">def ask_first_name
  puts "Quel est ton pr√©nom¬†?"
  print "> "
  first_name = gets.chomp
  return first_name
end</code></pre>

     <li>Si tu regardes les 4 lignes de code de cette m√©thode <code>ask_first_name</code>, tu vois qu'elle demande son pr√©nom √† l'utilisateur et retourne la saisie clavier de celui-ci. Ce <code>return</code> va √™tre renvoy√© dans la m√©thode <code>perform</code> et stock√© dans la variable <code>first_name</code>.</li>
    </ul>

    <li><b>La seconde ligne de <code>perform</code> est <code>last_name = ask_last_name</code></b>. C'est la m√™me logique qu'avant¬†: il faut ex√©cuter la m√©thode <code>ask_last_name</code> pour que son r√©sultat soit stock√© dans la variable <code>last_name</code></li>

    <ul>
      <li> Hop, l'ordinateur va ex√©cuter¬†: </li>
<pre><code class="language-ruby">def ask_last_name
  puts "Quel est ton nom de famille¬†?"
  print "> "
  last_name = gets.chomp
  return last_name
end</code></pre>

     <li>Idem que pr√©c√©demment, cette m√©thode demande, sur 4 lignes, le nom de famille de l'utilisateur et retourne sa saisie clavier. Ce <code>return</code> va √™tre renvoy√© dans la m√©thode <code>perform</code> et stock√© dans la variable <code>last_name</code>.</li>
    </ul>

    <li><b>La derni√®re ligne de <code>perform</code> fait <code>greet(first_name, last_name)</code></b>¬†: elle injecte les 2 variables <code>first_name</code> et <code>last_name</code> (issues des saisies clavier de l'utilisateur) dans la m√©thode <code>greet</code> qui va donc √™tre ex√©cut√©e.</li>

    <ul>
      <li>Voici le contenu de la m√©thode <code>greet</code> qui est ex√©cut√©e en dernier :</li>
<pre><code class="language-ruby">def greet(first_name, last_name)
  puts "Bienvenue, #{first_name} #{last_name} !"
end</code></pre>
      <li>Cette m√©thode va tout simplement imprimer les deux entr√©es de la m√©thode¬†: <code>first_name</code> et <code>last_name</code></li>
    </ul>
  </ul>

<h4>√âtape 3¬†: fin du programme</h4>
  <p>On vient de passer la derni√®re ligne de la m√©thode <code>perform</code>. L'ordinateur va voir s'il y a quelque chose apr√®s la ligne <code>perform</code>. Comme il n'y a plus de code, l'ex√©cution s'arr√™te</p>

<p>Au final chaque m√©thode a eu un r√¥le pr√©cis :</p>
<ul>
  <li>Les m√©thodes <code>ask_first_name</code> et <code>ask_last_name</code> ont un r√¥le simple de demande de saisie √† l'utilisateur et d'envoi de cette saisie.</li>
  <li>la m√©thode <code>perform</code> orchestre le tout en appelant ces deux m√©thodes puis en injectant leurs 2 retours dans la m√©thode <code>greet</code></li>
  <li>La m√©thode <code>greet</code> a √©galement un r√¥le simple d'affichage du pr√©nom et du nom qu'on lui donne.</li>
</ul>

<p>Voil√† un programme simple et bien organis√©¬†!</p>



<h2>4. Points importants √† retenir</h2>
<p>Les m√©thodes sont des petits robots-usines qui vous sont d√©vou√©s et qui ex√©cuteront inlassablement les m√™mes t√¢ches pour vous¬†: √† vous de coder votre petite arm√©e¬†!</p>
<p> Mais l'usage de m√©thode est aussi une technique indispensable pour bien ranger son code. Pour cr√©er une m√©thode il faut faire :</p>
<pre><code class="language-ruby">def ma_methode(local_variable)
  # du code qu'elle ex√©cutera √† chaque fois
end</code></pre>
<p>Et pour l'appeler (et lancer son ex√©cution) :</p>
<pre><code class="language-ruby">ma_methode(une_super_variable)</code></pre>

<p>Enfin, une bonne pratique est de ne pas faire d√©passer 25 lignes √† une m√©thode. Si ta m√©thode d√©passe 25 lignes, coupe-la en plusieurs m√©thodes remplissant chacune une petite partie du r√¥le de la m√©thode initiale.</p>

<h2>5. Pour aller plus loin</h2>
<p>LaunchSchool ont aussi √©crit <a href="https://launchschool.com/books/ruby/read/methods" target="_blank">un chouette article</a> assez exhaustif sur les m√©thodes de Ruby.</p>